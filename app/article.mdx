import ExampleSketch from './Examples/example-sketch.tsx'
import AchievementSketch1 from './Achievements/AchievementSketch1.tsx'
import AchievementToggle from './Achievements/AchievementToggle.tsx'
import KochFlake from './Examples/KockFlakeExample.tsx'
import SierpinskiTriangle from './Examples/SierpinskiTriangleExample.tsx'
import L_Maker from './L_Maker/L_Maker.tsx'
import TextLSystem from './TextLSystem/TextLSystem.tsx'
import DWD_editor from './DrawingsWithinDrawings/DWD_editor.tsx'
import TurtleSketch from './turtle/TurtleSketch.tsx'
import TreesSketch from './trees/TreesSketch.tsx'

import ChapterSeparator from './ChapterSeparator.tsx'
import Prose from './utils/Prose.tsx'
import MobileModal from './utils/MobileModal'

import Video from './utils/Video.tsx'
import Gif from './utils/Gif.tsx'

<MobileModal />

<Prose>
# How to programmatically touch grass

As a math and computer science enthusiast, I’m often told to touch grass. I never fully understood what that means, but one thing I’m sure of is that I don’t want to go outside. However, why not kill two birds with one stone and simulate some plants on my PC?
Today’s journey is about understanding how to make it possible using math, computer science, and a pinch of basic intuition.

<Gif url="https://giphy.com/embed/kRfIKQ6ADUJaM" width={480} height={264} />

At first, it is natural to take inspiration from state-of-the-art virtual botanic sceneries like the ones in video games. The results are amazing but they take the combined effort of tons of talented artists and designers because they are usually based on skillfully human-crafted assets.

</Prose>

<Video url="https://www.youtube.com/embed/PQQbLD-OHJY?start=31&playlist=PQQbLD-OHJY" />

<Prose>
Look at this view. That's without a doubt out of my league, from both artistic capabilities and manpower. 
Nah… the computer has to do all the heavy lifting for me.
Furthermore, like many other things in life, I don’t really care about the 3rd dimension or photorealism. A 2D drawing will be more than enough.
A procedural generation algorithm could be what I’m looking for.

The task at hand is quite different from your usual textbook problem. While still focusing on a specific topic you can't expect a clear-cut solution. The path we will be exploring is just one among infinitely many and it is meant to be a source of inspiration for you to dig your own unique way.

When facing such a broad problem, the first thing you do is shoot the messenger with a ton of questions:

1. What do you mean by recreating plants?
2. Which kind of plants?
3. Should this be an exact recreation or can we get away with some artistic liberties?

Well, as we said we will focus on drawings. The most important requirement is that the system must be flexible enough to draw any sort of plant: a tree, a fern, a blade of grass, a bush, and even algae.

<Gif url="https://giphy.com/embed/yFfPrA6TaURfa" width="480" height="269" />

The result should be pretty convincing but there has to be room for artistic expression. We want to be able to create any plant, even those that come from an alien planet, and have smiley faces as leaves.

<Gif
  url="https://giphy.com/embed/xUA7b1xHn1Jdy7Pk1q"
  width={400}
  height={400}
/>

</Prose>

<ChapterSeparator />

<Prose>
Okay, now that the goal is set, we can properly start. The next phase is arguably the most important one: don’t panic!
The infinitely many roads are all facing you and taking the first step can be daunting. Staring them won’t get you anywhere though, so let’s just pick without the fear of retracing our steps.

Let’s start by thinking about our biggest requirement: flexibility.

A lot of different scenarios, one system to draw them all.
If you think about it, this is no novelty for any mathematician. Arguably, math is built for this.

<Gif url="https://giphy.com/embed/ne3xrYlWtQFtC" width="480" height="205" />

Let’s take numbers for instance. They were first introduced to keep track of quantity. But the number of fingers on our hands, how many liters of fuel we need to get to Mars and the ratio between the circumference and the radius of a circle are widely different use cases.
Extracting common rules and concepts from different instances is called an abstraction.
As numbers are an essential abstraction to count, we need a common description of plants for our drawings.

The process of abstraction usually starts by distinguishing what are case-specific details and what intrinsically define the objects at hand.
To do this we can take some pictures of real plants we’d like to draw and literally blur the details by…. [blurring the pictures](maybe spoiler effect). Then we can toggle on and off different elements to see their role in defining the blurred picture.

This is not that different from what a painter or an illustrator would do.

<TreesSketch />

</Prose>
<Prose>
The first things to go away are leaves, flowers, fruits, berries, and all that stuff; 
What’s left is the branching structure, thus it is the most impacting element of the picture.
We’re also not interested in any kind of color or thickness for now, so we can get rid of those elements too by representing everything with straight lines
Nice! Let’s focus on that then. 
</Prose>

<Prose>
  Now that the image has been abstracted to its fundamental components we need
  to make it procedural and re-creatable by an algorithm.
</Prose>

<ChapterSeparator />

<Prose>
To do this it could be useful to start analyzing the problem from the start, gathering some ideas;

Let’s take (List of chosen images) and observe it with a scientist’s spirit.

</Prose>

<Prose>
Okay, despite the differences our abstractions look all similar.
But if you think about it, this time they are not just the details that change, there is something more fundamental going on. Can you spot it?

They are all at different scales! It seems that with our abstraction goggles microalgae and secular redwoods are much alike.

</Prose>

<Prose>
This weak influence of scale is no ordinary property because it comes with some heavy consequences.

If we take a tree for example and we zoom in on one of its branches, the only thing that changes is the scale. But since we noticed that this is no determining factor, we should expect something not that different from any other abstracted tree. And sure enough there it is, a tree camouflaged as part of a bigger one.

With some necessary formalities, this property takes the name of self-similarity.
Much can be said about its implications and impact on mathematics. Nonetheless, for the sake of time, I’ll leave that to your own curiosity.

Coming back to our problem, our recent discovery allows us to describe a tree just as a bunch of smaller trees glued together! Amazing!

</Prose>

<Prose>
As you can see the self similarity of this simple tree implies that each part of the tree can be described by the single component:

If we associate this base element with the symbol T we can arrive to a weird definition:
T = ½ T + ½ T where for defining T we reference the definition itself.

[animation of building the binary tree through recurrence]

These types of definitions are called recurrences and both math and computer science are full of them.

You may be spotting a problem though, the definition by recursion implies the creation of a perfect self-similar tree but that is not what’s outside in the nearest park.
That is definitely a valid concern but for now, let’s try to tame the simplest case first. We can add back the complexity later.
Let’s look at a perfect self-similar plant!

</Prose>

<ChapterSeparator />

<Prose>
What would it look like? How would you draw it?

Well, firstly there are actually some almost self-similar plants in nature. Look at them!
[Images]
If we want to recreate them we may go back to the recurrent definition and literally put a smaller copy of the whole drawing as a part of the drawing itself. Much like when you make two mirrors face each other, or a webcam pointed at his video output.

Here you can play around with this concept. Try and build something that resembles a plant

</Prose>

<DWD_editor />

<Prose>
I Hope you were successful in your mission. But despite that, I hope you can agree that this method has its flaws. First of all, we don’t really have control over the copies, they are no more than that, and we don’t choose the depth of the recurrence. Furthermore, we don’t have a clear description of the plant at hand.
We need to improve this!

</Prose>

<ChapterSeparator />
<Prose>
Let’s go back again to our abstracted plants. Can we abstract them even more? Is there a pattern between all of them?
Despite all the case-specific intricacies, we reduced every drawing to just being made by straight segments.

Thanks to this simplification it is sufficient for us to use what is arguably the simplest way of drawing programmatically: Turtle graphics.

Picture a turtle with a pen strapped on the back. The turtle can just move forward, rotate around its center and get the pen on and off the paper. If you think about it for a moment, or even try to sketch something you’ll realize that these 4 elementary moves are sufficient to draw any picture.

Let’s give a name to those instructions: F means go forward with the pen down, + means rotate to the left, - means rotate to the right and f means forward with the pen up.

To make things easier we can assign a fixed amount of movement and rotation per symbol. For instance, we can say that all translations are of 10 px while rotations happen in 10 deg steps.
Even with this limitation, we can draw pretty much every abstracted plant we encountered so far. Let’s look at this simple branch for instance

</Prose>

<Prose>

This works pretty well for our perfect plant! But it still has its own problems. First of all, we don’t really have control over the copies, they are no more than that, and we don’t choose the depth of the recurrence. Furthermore, we don’t have a clear description of the plant at hand.
We need to improve this!

</Prose>

<ChapterSeparator />
<Prose>

Let’s go back again to our abstracted plants. Can we abstract them even more? Is there a pattern between all of them?
Despite all the case-specific intricacies, all the drawings are just made of straight segments.
So we just need a way to make a computer draw that and yet again the possibilities are endless.
For our objective, we’re going to use what is arguably the simplest way of drawing programmatically: Turtle graphics.

Picture a turtle with a pen strapped on the back. The turtle can just move forward, rotate around its center and get the pen on and off the paper. Let’s give a name to those instructions: F means go forward with the pen down, + means rotate to the left, - means rotate to the right and f means forward with the pen up.

To make things easier we can assign a fixed amount of movement and rotation per symbol. For instance, we can say that all translations are of 10 px while rotations happen in 10 deg steps.

With this simple set of symbols, we can draw pretty much every abstracted plant we encountered so far. Let’s look at this simple branch for instance.

(Commentary on the branch drawing)

</Prose>

<TurtleSketch withStack={false} defaultString="F+F-F" />

<Prose>
As you can see the process is not particularly hard but a bit convoluted.
Especially if you consider that going back to the beginning of an already drawn branch, to then draw the next, implies doubling the number of instructions.

To unclutter this back-and-forth process we could keep track of the turtle’s movement using a stack: a way of organizing data that, just like a stack of plates, lets you add and remove elements only from the top.
To represent these two actions we’ll introduce two new symbols: [ ].

When the turtle reads a [ it will store its current position and orientation while upon reading a ] it gets the position and orientation last stored, moves there with the pen up, aligns itself, and discards them.

Now we can try again with the simple branch:

</Prose>

<TurtleSketch withStack={true} defaultString="FF[+F[+F]]F-F" />

<Prose>
  Much cleaner now! Perfect! Now that we have the tool to draw with, we can
  tackle the self-similarity.
</Prose>

<ChapterSeparator />

<Prose>
Let’s start by recovering the recurrent definition of tree “T = ½ T + ½ T” stated earlier (link) and formalizing it using the branch constructed in the preceding chapter, we obtain T = F[+T][-T].

The exact solution to this “equation” would require a shape that is infinitely self-similar. Not only would that be very difficult to define but we don’t even really care about it since all plants are finite. Instead, we can lose the symmetry of the equality and read it more like an assignment, and so substitute that ‘=’ with a ‘->’ to mark the difference.

T ->F[+T][-T]
Now we can just start from a T and iteratively apply the assignment by substituting each T with the right side of the arrow. A literal find and replace.

So we go from T to F[+T][-T] to F[+F[+T][-T]][-F[+T][-T]] and then to F[+F[+F[+T][-T]][-F[+T][-T]]][-F[+F[+T][-T]][-F[+T][-T]]] . We can draw the result using our trusted turtle and here it is.

</Prose>

<Prose>
Amazing! That is basically a line binary tree!

Now that we have proof that our discovery works for at least a kind of tree, it is time to formalize our method and explore its capabilities.

</Prose>

<ChapterSeparator />

<Prose>
It is safe to say that we can split the task between two different systems that work together: one for the generation of the strings and one for the drawings.

The latter is easy, we can use any basic turtle engine.
For the former, we need to think back at what we did and try to formalize the process.

We started by defining a set of symbols, the F, +, -, and f. We can call the set of characters we expect to manage, an alphabet.

Then we defined the “relation” between our characters. We said that every T will turn in F[+T][-T]. We called it an assignment but I think that, given we don’t change the “value” of T, production would be a more suitable term.

In our simple example, we needed just one production but there is nothing against having multiple ones. We just need to be careful to avoid overlaps. Each character should be associated with just one production. At least for now ;)

Then we chose a character to start from, the initial T.
Since it’s kind of inexplicably there at the beginning we can call it an axiom and once again we shouldn’t limit ourselves to just one character. It may also be a string.

Once defined T as the axiom, i.e. the start, the process becomes an iterative find and replace.

We iterate through each character of the string and look for a match among the productions. If one is found we substitute the right side of the production with the character we were considering, otherwise we just leave it there and proceed with the next one.
Once we’ve processed each character we start all over again until the desired level of detail is reached

</Prose>

<TextLSystem/ >

<Prose>

What we just described is called a Lyndelmier System from the bright botanist who first came up with it. Commonly abbreviated to L-systems they are an example of a broader class of computational objects called formal grammars.

If you think about it, we are assigning to each branching structure a sequence of characters, a sentence, and we are trying to generate only “meaningful” ones in the sense of actually representing a plant. It is not that different from the generation of a “meaningful” sentence in English, in the sense of conveying actual meaning. But while in English we are concerned with the meaning of each word, here we only care about the structure of the sentence, about its grammatical coherence. So we only need the grammar of this new weird language.

The magic of separating the string generation from the drawing is that while the first system captures the essence of the structure the second one leaves a lot of room for artistic expression! We can add as many interpretations of the characters as we want, ranging from drawing a flower to producing a certain musical note to changing the color of the line or whatever; and we are not limited to the two dimensions either! We can just add more symbols and interpret them as different movements in space for instance.
This is the perfect way to regain those scenario-specific details we lost by blurring the pictures at the beginning!

</Prose>

<Prose>
Once again we could be here talking for hours about L-systems and their huge amount of variations, possibilities, applications, classifications, and whatnot and  once again I’ll leave that to your own curiosity and maybe a future article/video.

For now, you can try and experiment with a graphical version of what we discussed so far. Here you’ll be no longer restrained with a fixed amount of rotation and length per character so you can let your imagination roam free.

</Prose>

<L_Maker />

<Prose>
  Finally, let’s just get back to an issue we left behind: the variation.
</Prose>

<ChapterSeparator />
<Prose>
We now need to exit the world of perfection and go back to reality. We can use a trick that seems to come so easily to nature: randomness.
To achieve this we need to lose the determinism of our system, meaning that one set of alphabet, productions, and axioms will no longer always produce the same drawing. And the easiest way to do that is by allowing overlap in the productions.

You see if there are multiple productions from the same character the procedure has to make a choice. You may go for the first match for instance, but much more interestingly you can make it randomly. You can make the computer just roll a die.

In this way, we break the stiffness of self-similarity and allow an exponentially increasing amount of organic results.

Our branching structure is officially tamed!
And since we said that the details and artistic interpretations are easily introduceable in the drawing system we are finally all done!

Here you can experiment with the L-system as much as you want!

</Prose>

<ChapterSeparator />
<Prose>

Our journey stops here at the moment.
We successfully managed to make a computer programmatically tame the intricacies of the organic shapes that surround us. The key takeaway here is not the destination though.
L-systems are just one among a myriad of different plant drawing algorithms, each with its own story, pros, and cons. What I’d like you to appreciate is how we got here. How we didn’t stop facing a task so broad and complex and how by iteratively going through simplifications and hopefully intuitive choices we produced a solution quite elegant in its simplicity.

I also hope that you are left with few answers but many new questions in mind and I highly encourage you to take the loose threads of this article as an excuse to dive deeper into this topic. Trust me, there is an infinite amount of wonders hidden between the leaves of a computer-generated plant!

</Prose>

<ChapterSeparator />

<Prose>**CREDITS**</Prose>
